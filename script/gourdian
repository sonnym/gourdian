#! /usr/bin/env node

var fs = require("fs")
  , path = require("path")

  , node_modules_waiting_for_exit = 0;

// main
if (process.argv[2] == "--init-submodules") {
  update_node_modules();

} else if (process.argv[2] == "--init") {
  update_node_modules(function() {
    create_directory_structure();
    copy_files_into_directories();

    console.log("---\nNew project init complete!\n");
  });
} else {
  console.log("Usage:  script/gourdian --init");
}

function update_node_modules(callback) {
  console.log("---\nInitializing and updating node_modules directory. . .\n---");

  parallel_update_node_modules();

  // everything later in the initialization process depends on the modules being present
  var module_waiting_interval_id = setInterval(function() {
    if (node_modules_waiting_for_exit == 0) {
      clearInterval(module_waiting_interval_id);
      if (callback) callback();
    }
  }, 100);
}

function parallel_update_node_modules() {
  var spawn = require("child_process").spawn
    , node_modules = fs.readdirSync(path.join(__dirname, "..", "node_modules"));

  for (var i = 0, l = node_modules.length; i < l; i++) {
    node_modules_waiting_for_exit++;

    spawn("git", ["submodule", "update", "--init", "--recursive", path.join(__dirname, "..", "node_modules", node_modules[i])]).on("exit", function() {
      node_modules_waiting_for_exit--;
    });
  }
}

function create_directory_structure() {
  console.log("---\nCreating directories. . . \n---");

  var gourdian = require(path.join(__dirname, "..", "core", "gourdian"))
    , directory_structure = [{ "app": ["m", "v", "c"] }, "config", "log", { "public": ["css", "js"] }, { "test": ["integration", "lib", "performance", "unit"] }]
    , directories = reduce_directory_structure(gourdian.ROOT, directory_structure);

  gourdian._.each(directories, function(directory) {
    if (path.existsSync(directory)) {
      console.log(directory + " present");
    } else {
      fs.mkdirSync(directory, 0755);
      console.log(directory + " created");
    }
  });
}

function copy_files_into_directories() {
  console.log("---\nCopying files. . . \n---");

  var gourdian = require(path.join(__dirname, "..", "core", "gourdian"))
    , init_path = path.join(gourdian.ROOT, "core", "boilerplate", "init");

  directory_descent_wrapper(init_path, function(source) {
    var source_rel = source.substring(gourdian.ROOT.length + 1)
      , source_rel_array = gourdian._.rest((source_rel.split("/") || source.split("\\")), 3)
      , destination = path.join(gourdian.ROOT, gourdian._.reduce(source_rel_array, function(memo, path_part) { return path.join(memo, path_part) }));

  if (path.existsSync(destination)) {
    console.log(destination + " present");
  } else {
      fs.readFile(source, function(read_err, buf) {
        if (read_err) console.log("\nERROR:  Unable to read file " + source);

        fs.writeFile(destination, buf, function(write_err) {
          if (write_err) console.log("\nERROR: Unable to write file " + destination + " " + write_err);
          else console.log(destination + " created");
        });
      });
    }
  });
}

function reduce_directory_structure(initial_value, obj) {
  var gourdian = require(path.join(__dirname, "..", "core", "gourdian"))

  return gourdian._.flatten(gourdian._.map(obj, function(iterated_object) {
    if (typeof iterated_object === "object") {
      var key = gourdian._.keys(iterated_object)[0];
      return [ path.join(initial_value, key), reduce_directory_structure(path.join(initial_value, key), gourdian._.values(iterated_object)[0]) ];
    } else if (typeof iterated_object === "string") {
      return path.join(initial_value, iterated_object);
    }
  }));
}

function directory_descent_wrapper(full_path, callback) {
  var gourdian = require(path.join(__dirname, "..", "core", "gourdian"))
    , files = fs.readdirSync(full_path);

  gourdian._.each(files, function(file) {
    var file_path_abs = path.join(full_path, file);

    stats = fs.statSync(file_path_abs);
    if (stats.isDirectory()) {
      directory_descent_wrapper(file_path_abs, callback);
    } else {
      callback(file_path_abs);
    }
  });
}
